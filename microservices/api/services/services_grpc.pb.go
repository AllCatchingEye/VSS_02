// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             v3.21.12
// source: microservices/api/services/services.proto

package services

import (
	context "context"
	customerApi "gitlab.lrz.de/vss/semester/ob-23ss/blatt-2/blatt2-grp06/microservices/api/customerApi"
	orderApi "gitlab.lrz.de/vss/semester/ob-23ss/blatt-2/blatt2-grp06/microservices/api/orderApi"
	paymentApi "gitlab.lrz.de/vss/semester/ob-23ss/blatt-2/blatt2-grp06/microservices/api/paymentApi"
	shipmentApi "gitlab.lrz.de/vss/semester/ob-23ss/blatt-2/blatt2-grp06/microservices/api/shipmentApi"
	stockApi "gitlab.lrz.de/vss/semester/ob-23ss/blatt-2/blatt2-grp06/microservices/api/stockApi"
	supplierApi "gitlab.lrz.de/vss/semester/ob-23ss/blatt-2/blatt2-grp06/microservices/api/supplierApi"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	CustomerService_AddCustomer_FullMethodName    = "/services.CustomerService/AddCustomer"
	CustomerService_GetCustomer_FullMethodName    = "/services.CustomerService/GetCustomer"
	CustomerService_RemoveCustomer_FullMethodName = "/services.CustomerService/RemoveCustomer"
)

// CustomerServiceClient is the client API for CustomerService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CustomerServiceClient interface {
	AddCustomer(ctx context.Context, in *customerApi.AddCustomerRequest, opts ...grpc.CallOption) (*customerApi.AddCustomerReply, error)
	GetCustomer(ctx context.Context, in *customerApi.GetCustomerRequest, opts ...grpc.CallOption) (*customerApi.GetCustomerReply, error)
	RemoveCustomer(ctx context.Context, in *customerApi.RemoveCustomerRequest, opts ...grpc.CallOption) (*customerApi.RemoveCustomerReply, error)
}

type customerServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewCustomerServiceClient(cc grpc.ClientConnInterface) CustomerServiceClient {
	return &customerServiceClient{cc}
}

func (c *customerServiceClient) AddCustomer(ctx context.Context, in *customerApi.AddCustomerRequest, opts ...grpc.CallOption) (*customerApi.AddCustomerReply, error) {
	out := new(customerApi.AddCustomerReply)
	err := c.cc.Invoke(ctx, CustomerService_AddCustomer_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *customerServiceClient) GetCustomer(ctx context.Context, in *customerApi.GetCustomerRequest, opts ...grpc.CallOption) (*customerApi.GetCustomerReply, error) {
	out := new(customerApi.GetCustomerReply)
	err := c.cc.Invoke(ctx, CustomerService_GetCustomer_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *customerServiceClient) RemoveCustomer(ctx context.Context, in *customerApi.RemoveCustomerRequest, opts ...grpc.CallOption) (*customerApi.RemoveCustomerReply, error) {
	out := new(customerApi.RemoveCustomerReply)
	err := c.cc.Invoke(ctx, CustomerService_RemoveCustomer_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CustomerServiceServer is the server API for CustomerService service.
// All implementations must embed UnimplementedCustomerServiceServer
// for forward compatibility
type CustomerServiceServer interface {
	AddCustomer(context.Context, *customerApi.AddCustomerRequest) (*customerApi.AddCustomerReply, error)
	GetCustomer(context.Context, *customerApi.GetCustomerRequest) (*customerApi.GetCustomerReply, error)
	RemoveCustomer(context.Context, *customerApi.RemoveCustomerRequest) (*customerApi.RemoveCustomerReply, error)
	mustEmbedUnimplementedCustomerServiceServer()
}

// UnimplementedCustomerServiceServer must be embedded to have forward compatible implementations.
type UnimplementedCustomerServiceServer struct {
}

func (UnimplementedCustomerServiceServer) AddCustomer(context.Context, *customerApi.AddCustomerRequest) (*customerApi.AddCustomerReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddCustomer not implemented")
}
func (UnimplementedCustomerServiceServer) GetCustomer(context.Context, *customerApi.GetCustomerRequest) (*customerApi.GetCustomerReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCustomer not implemented")
}
func (UnimplementedCustomerServiceServer) RemoveCustomer(context.Context, *customerApi.RemoveCustomerRequest) (*customerApi.RemoveCustomerReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveCustomer not implemented")
}
func (UnimplementedCustomerServiceServer) mustEmbedUnimplementedCustomerServiceServer() {}

// UnsafeCustomerServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CustomerServiceServer will
// result in compilation errors.
type UnsafeCustomerServiceServer interface {
	mustEmbedUnimplementedCustomerServiceServer()
}

func RegisterCustomerServiceServer(s grpc.ServiceRegistrar, srv CustomerServiceServer) {
	s.RegisterService(&CustomerService_ServiceDesc, srv)
}

func _CustomerService_AddCustomer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(customerApi.AddCustomerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CustomerServiceServer).AddCustomer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CustomerService_AddCustomer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CustomerServiceServer).AddCustomer(ctx, req.(*customerApi.AddCustomerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CustomerService_GetCustomer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(customerApi.GetCustomerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CustomerServiceServer).GetCustomer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CustomerService_GetCustomer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CustomerServiceServer).GetCustomer(ctx, req.(*customerApi.GetCustomerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CustomerService_RemoveCustomer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(customerApi.RemoveCustomerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CustomerServiceServer).RemoveCustomer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CustomerService_RemoveCustomer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CustomerServiceServer).RemoveCustomer(ctx, req.(*customerApi.RemoveCustomerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// CustomerService_ServiceDesc is the grpc.ServiceDesc for CustomerService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CustomerService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "services.CustomerService",
	HandlerType: (*CustomerServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddCustomer",
			Handler:    _CustomerService_AddCustomer_Handler,
		},
		{
			MethodName: "GetCustomer",
			Handler:    _CustomerService_GetCustomer_Handler,
		},
		{
			MethodName: "RemoveCustomer",
			Handler:    _CustomerService_RemoveCustomer_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "microservices/api/services/services.proto",
}

const (
	OrderService_NewOrder_FullMethodName          = "/services.OrderService/NewOrder"
	OrderService_GetOrder_FullMethodName          = "/services.OrderService/GetOrder"
	OrderService_SetOrderStatus_FullMethodName    = "/services.OrderService/SetOrderStatus"
	OrderService_SetPaymentStatus_FullMethodName  = "/services.OrderService/SetPaymentStatus"
	OrderService_SetDeliveryStatus_FullMethodName = "/services.OrderService/SetDeliveryStatus"
)

// OrderServiceClient is the client API for OrderService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type OrderServiceClient interface {
	NewOrder(ctx context.Context, in *orderApi.NewOrderRequest, opts ...grpc.CallOption) (*orderApi.NewOrderReply, error)
	GetOrder(ctx context.Context, in *orderApi.GetOrderRequest, opts ...grpc.CallOption) (*orderApi.GetOrderReply, error)
	SetOrderStatus(ctx context.Context, in *orderApi.SetOrderStatusRequest, opts ...grpc.CallOption) (*orderApi.SetOrderStatusReply, error)
	SetPaymentStatus(ctx context.Context, in *orderApi.SetPaymentStatusRequest, opts ...grpc.CallOption) (*orderApi.SetPaymentStatusReply, error)
	SetDeliveryStatus(ctx context.Context, in *orderApi.SetDeliveryStatusRequest, opts ...grpc.CallOption) (*orderApi.SetDeliveryStatusReply, error)
}

type orderServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewOrderServiceClient(cc grpc.ClientConnInterface) OrderServiceClient {
	return &orderServiceClient{cc}
}

func (c *orderServiceClient) NewOrder(ctx context.Context, in *orderApi.NewOrderRequest, opts ...grpc.CallOption) (*orderApi.NewOrderReply, error) {
	out := new(orderApi.NewOrderReply)
	err := c.cc.Invoke(ctx, OrderService_NewOrder_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *orderServiceClient) GetOrder(ctx context.Context, in *orderApi.GetOrderRequest, opts ...grpc.CallOption) (*orderApi.GetOrderReply, error) {
	out := new(orderApi.GetOrderReply)
	err := c.cc.Invoke(ctx, OrderService_GetOrder_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *orderServiceClient) SetOrderStatus(ctx context.Context, in *orderApi.SetOrderStatusRequest, opts ...grpc.CallOption) (*orderApi.SetOrderStatusReply, error) {
	out := new(orderApi.SetOrderStatusReply)
	err := c.cc.Invoke(ctx, OrderService_SetOrderStatus_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *orderServiceClient) SetPaymentStatus(ctx context.Context, in *orderApi.SetPaymentStatusRequest, opts ...grpc.CallOption) (*orderApi.SetPaymentStatusReply, error) {
	out := new(orderApi.SetPaymentStatusReply)
	err := c.cc.Invoke(ctx, OrderService_SetPaymentStatus_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *orderServiceClient) SetDeliveryStatus(ctx context.Context, in *orderApi.SetDeliveryStatusRequest, opts ...grpc.CallOption) (*orderApi.SetDeliveryStatusReply, error) {
	out := new(orderApi.SetDeliveryStatusReply)
	err := c.cc.Invoke(ctx, OrderService_SetDeliveryStatus_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// OrderServiceServer is the server API for OrderService service.
// All implementations must embed UnimplementedOrderServiceServer
// for forward compatibility
type OrderServiceServer interface {
	NewOrder(context.Context, *orderApi.NewOrderRequest) (*orderApi.NewOrderReply, error)
	GetOrder(context.Context, *orderApi.GetOrderRequest) (*orderApi.GetOrderReply, error)
	SetOrderStatus(context.Context, *orderApi.SetOrderStatusRequest) (*orderApi.SetOrderStatusReply, error)
	SetPaymentStatus(context.Context, *orderApi.SetPaymentStatusRequest) (*orderApi.SetPaymentStatusReply, error)
	SetDeliveryStatus(context.Context, *orderApi.SetDeliveryStatusRequest) (*orderApi.SetDeliveryStatusReply, error)
	mustEmbedUnimplementedOrderServiceServer()
}

// UnimplementedOrderServiceServer must be embedded to have forward compatible implementations.
type UnimplementedOrderServiceServer struct {
}

func (UnimplementedOrderServiceServer) NewOrder(context.Context, *orderApi.NewOrderRequest) (*orderApi.NewOrderReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NewOrder not implemented")
}
func (UnimplementedOrderServiceServer) GetOrder(context.Context, *orderApi.GetOrderRequest) (*orderApi.GetOrderReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetOrder not implemented")
}
func (UnimplementedOrderServiceServer) SetOrderStatus(context.Context, *orderApi.SetOrderStatusRequest) (*orderApi.SetOrderStatusReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetOrderStatus not implemented")
}
func (UnimplementedOrderServiceServer) SetPaymentStatus(context.Context, *orderApi.SetPaymentStatusRequest) (*orderApi.SetPaymentStatusReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetPaymentStatus not implemented")
}
func (UnimplementedOrderServiceServer) SetDeliveryStatus(context.Context, *orderApi.SetDeliveryStatusRequest) (*orderApi.SetDeliveryStatusReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetDeliveryStatus not implemented")
}
func (UnimplementedOrderServiceServer) mustEmbedUnimplementedOrderServiceServer() {}

// UnsafeOrderServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to OrderServiceServer will
// result in compilation errors.
type UnsafeOrderServiceServer interface {
	mustEmbedUnimplementedOrderServiceServer()
}

func RegisterOrderServiceServer(s grpc.ServiceRegistrar, srv OrderServiceServer) {
	s.RegisterService(&OrderService_ServiceDesc, srv)
}

func _OrderService_NewOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(orderApi.NewOrderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrderServiceServer).NewOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OrderService_NewOrder_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrderServiceServer).NewOrder(ctx, req.(*orderApi.NewOrderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OrderService_GetOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(orderApi.GetOrderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrderServiceServer).GetOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OrderService_GetOrder_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrderServiceServer).GetOrder(ctx, req.(*orderApi.GetOrderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OrderService_SetOrderStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(orderApi.SetOrderStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrderServiceServer).SetOrderStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OrderService_SetOrderStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrderServiceServer).SetOrderStatus(ctx, req.(*orderApi.SetOrderStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OrderService_SetPaymentStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(orderApi.SetPaymentStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrderServiceServer).SetPaymentStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OrderService_SetPaymentStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrderServiceServer).SetPaymentStatus(ctx, req.(*orderApi.SetPaymentStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OrderService_SetDeliveryStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(orderApi.SetDeliveryStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrderServiceServer).SetDeliveryStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OrderService_SetDeliveryStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrderServiceServer).SetDeliveryStatus(ctx, req.(*orderApi.SetDeliveryStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// OrderService_ServiceDesc is the grpc.ServiceDesc for OrderService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var OrderService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "services.OrderService",
	HandlerType: (*OrderServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "NewOrder",
			Handler:    _OrderService_NewOrder_Handler,
		},
		{
			MethodName: "GetOrder",
			Handler:    _OrderService_GetOrder_Handler,
		},
		{
			MethodName: "SetOrderStatus",
			Handler:    _OrderService_SetOrderStatus_Handler,
		},
		{
			MethodName: "SetPaymentStatus",
			Handler:    _OrderService_SetPaymentStatus_Handler,
		},
		{
			MethodName: "SetDeliveryStatus",
			Handler:    _OrderService_SetDeliveryStatus_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "microservices/api/services/services.proto",
}

const (
	PaymentService_PayMyOrder_FullMethodName   = "/services.PaymentService/PayMyOrder"
	PaymentService_IsOrderPayed_FullMethodName = "/services.PaymentService/IsOrderPayed"
)

// PaymentServiceClient is the client API for PaymentService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type PaymentServiceClient interface {
	PayMyOrder(ctx context.Context, in *paymentApi.PayMyOrderRequest, opts ...grpc.CallOption) (*paymentApi.PayMyOrderReply, error)
	IsOrderPayed(ctx context.Context, in *paymentApi.IsOrderPayedRequest, opts ...grpc.CallOption) (*paymentApi.IsOrderPayedReply, error)
}

type paymentServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewPaymentServiceClient(cc grpc.ClientConnInterface) PaymentServiceClient {
	return &paymentServiceClient{cc}
}

func (c *paymentServiceClient) PayMyOrder(ctx context.Context, in *paymentApi.PayMyOrderRequest, opts ...grpc.CallOption) (*paymentApi.PayMyOrderReply, error) {
	out := new(paymentApi.PayMyOrderReply)
	err := c.cc.Invoke(ctx, PaymentService_PayMyOrder_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *paymentServiceClient) IsOrderPayed(ctx context.Context, in *paymentApi.IsOrderPayedRequest, opts ...grpc.CallOption) (*paymentApi.IsOrderPayedReply, error) {
	out := new(paymentApi.IsOrderPayedReply)
	err := c.cc.Invoke(ctx, PaymentService_IsOrderPayed_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PaymentServiceServer is the server API for PaymentService service.
// All implementations must embed UnimplementedPaymentServiceServer
// for forward compatibility
type PaymentServiceServer interface {
	PayMyOrder(context.Context, *paymentApi.PayMyOrderRequest) (*paymentApi.PayMyOrderReply, error)
	IsOrderPayed(context.Context, *paymentApi.IsOrderPayedRequest) (*paymentApi.IsOrderPayedReply, error)
	mustEmbedUnimplementedPaymentServiceServer()
}

// UnimplementedPaymentServiceServer must be embedded to have forward compatible implementations.
type UnimplementedPaymentServiceServer struct {
}

func (UnimplementedPaymentServiceServer) PayMyOrder(context.Context, *paymentApi.PayMyOrderRequest) (*paymentApi.PayMyOrderReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PayMyOrder not implemented")
}
func (UnimplementedPaymentServiceServer) IsOrderPayed(context.Context, *paymentApi.IsOrderPayedRequest) (*paymentApi.IsOrderPayedReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsOrderPayed not implemented")
}
func (UnimplementedPaymentServiceServer) mustEmbedUnimplementedPaymentServiceServer() {}

// UnsafePaymentServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PaymentServiceServer will
// result in compilation errors.
type UnsafePaymentServiceServer interface {
	mustEmbedUnimplementedPaymentServiceServer()
}

func RegisterPaymentServiceServer(s grpc.ServiceRegistrar, srv PaymentServiceServer) {
	s.RegisterService(&PaymentService_ServiceDesc, srv)
}

func _PaymentService_PayMyOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(paymentApi.PayMyOrderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaymentServiceServer).PayMyOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PaymentService_PayMyOrder_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaymentServiceServer).PayMyOrder(ctx, req.(*paymentApi.PayMyOrderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PaymentService_IsOrderPayed_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(paymentApi.IsOrderPayedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaymentServiceServer).IsOrderPayed(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PaymentService_IsOrderPayed_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaymentServiceServer).IsOrderPayed(ctx, req.(*paymentApi.IsOrderPayedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// PaymentService_ServiceDesc is the grpc.ServiceDesc for PaymentService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var PaymentService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "services.PaymentService",
	HandlerType: (*PaymentServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "PayMyOrder",
			Handler:    _PaymentService_PayMyOrder_Handler,
		},
		{
			MethodName: "IsOrderPayed",
			Handler:    _PaymentService_IsOrderPayed_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "microservices/api/services/services.proto",
}

const (
	ShipmentService_ShipMyOrder_FullMethodName = "/services.ShipmentService/ShipMyOrder"
)

// ShipmentServiceClient is the client API for ShipmentService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ShipmentServiceClient interface {
	ShipMyOrder(ctx context.Context, in *shipmentApi.ShipMyOrderRequest, opts ...grpc.CallOption) (*shipmentApi.ShipMyOrderReply, error)
}

type shipmentServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewShipmentServiceClient(cc grpc.ClientConnInterface) ShipmentServiceClient {
	return &shipmentServiceClient{cc}
}

func (c *shipmentServiceClient) ShipMyOrder(ctx context.Context, in *shipmentApi.ShipMyOrderRequest, opts ...grpc.CallOption) (*shipmentApi.ShipMyOrderReply, error) {
	out := new(shipmentApi.ShipMyOrderReply)
	err := c.cc.Invoke(ctx, ShipmentService_ShipMyOrder_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ShipmentServiceServer is the server API for ShipmentService service.
// All implementations must embed UnimplementedShipmentServiceServer
// for forward compatibility
type ShipmentServiceServer interface {
	ShipMyOrder(context.Context, *shipmentApi.ShipMyOrderRequest) (*shipmentApi.ShipMyOrderReply, error)
	mustEmbedUnimplementedShipmentServiceServer()
}

// UnimplementedShipmentServiceServer must be embedded to have forward compatible implementations.
type UnimplementedShipmentServiceServer struct {
}

func (UnimplementedShipmentServiceServer) ShipMyOrder(context.Context, *shipmentApi.ShipMyOrderRequest) (*shipmentApi.ShipMyOrderReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ShipMyOrder not implemented")
}
func (UnimplementedShipmentServiceServer) mustEmbedUnimplementedShipmentServiceServer() {}

// UnsafeShipmentServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ShipmentServiceServer will
// result in compilation errors.
type UnsafeShipmentServiceServer interface {
	mustEmbedUnimplementedShipmentServiceServer()
}

func RegisterShipmentServiceServer(s grpc.ServiceRegistrar, srv ShipmentServiceServer) {
	s.RegisterService(&ShipmentService_ServiceDesc, srv)
}

func _ShipmentService_ShipMyOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(shipmentApi.ShipMyOrderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShipmentServiceServer).ShipMyOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ShipmentService_ShipMyOrder_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShipmentServiceServer).ShipMyOrder(ctx, req.(*shipmentApi.ShipMyOrderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ShipmentService_ServiceDesc is the grpc.ServiceDesc for ShipmentService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ShipmentService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "services.ShipmentService",
	HandlerType: (*ShipmentServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ShipMyOrder",
			Handler:    _ShipmentService_ShipMyOrder_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "microservices/api/services/services.proto",
}

const (
	StockService_AddProducts_FullMethodName   = "/services.StockService/AddProducts"
	StockService_GetProducts_FullMethodName   = "/services.StockService/GetProducts"
	StockService_RemoveProduct_FullMethodName = "/services.StockService/RemoveProduct"
)

// StockServiceClient is the client API for StockService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type StockServiceClient interface {
	AddProducts(ctx context.Context, in *stockApi.AddProductsRequest, opts ...grpc.CallOption) (*stockApi.AddProductsReply, error)
	GetProducts(ctx context.Context, in *stockApi.GetProductsRequest, opts ...grpc.CallOption) (*stockApi.GetProductsReply, error)
	RemoveProduct(ctx context.Context, in *stockApi.RemoveProductRequest, opts ...grpc.CallOption) (*stockApi.RemoveProductReply, error)
}

type stockServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewStockServiceClient(cc grpc.ClientConnInterface) StockServiceClient {
	return &stockServiceClient{cc}
}

func (c *stockServiceClient) AddProducts(ctx context.Context, in *stockApi.AddProductsRequest, opts ...grpc.CallOption) (*stockApi.AddProductsReply, error) {
	out := new(stockApi.AddProductsReply)
	err := c.cc.Invoke(ctx, StockService_AddProducts_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stockServiceClient) GetProducts(ctx context.Context, in *stockApi.GetProductsRequest, opts ...grpc.CallOption) (*stockApi.GetProductsReply, error) {
	out := new(stockApi.GetProductsReply)
	err := c.cc.Invoke(ctx, StockService_GetProducts_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stockServiceClient) RemoveProduct(ctx context.Context, in *stockApi.RemoveProductRequest, opts ...grpc.CallOption) (*stockApi.RemoveProductReply, error) {
	out := new(stockApi.RemoveProductReply)
	err := c.cc.Invoke(ctx, StockService_RemoveProduct_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// StockServiceServer is the server API for StockService service.
// All implementations must embed UnimplementedStockServiceServer
// for forward compatibility
type StockServiceServer interface {
	AddProducts(context.Context, *stockApi.AddProductsRequest) (*stockApi.AddProductsReply, error)
	GetProducts(context.Context, *stockApi.GetProductsRequest) (*stockApi.GetProductsReply, error)
	RemoveProduct(context.Context, *stockApi.RemoveProductRequest) (*stockApi.RemoveProductReply, error)
	mustEmbedUnimplementedStockServiceServer()
}

// UnimplementedStockServiceServer must be embedded to have forward compatible implementations.
type UnimplementedStockServiceServer struct {
}

func (UnimplementedStockServiceServer) AddProducts(context.Context, *stockApi.AddProductsRequest) (*stockApi.AddProductsReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddProducts not implemented")
}
func (UnimplementedStockServiceServer) GetProducts(context.Context, *stockApi.GetProductsRequest) (*stockApi.GetProductsReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProducts not implemented")
}
func (UnimplementedStockServiceServer) RemoveProduct(context.Context, *stockApi.RemoveProductRequest) (*stockApi.RemoveProductReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveProduct not implemented")
}
func (UnimplementedStockServiceServer) mustEmbedUnimplementedStockServiceServer() {}

// UnsafeStockServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to StockServiceServer will
// result in compilation errors.
type UnsafeStockServiceServer interface {
	mustEmbedUnimplementedStockServiceServer()
}

func RegisterStockServiceServer(s grpc.ServiceRegistrar, srv StockServiceServer) {
	s.RegisterService(&StockService_ServiceDesc, srv)
}

func _StockService_AddProducts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(stockApi.AddProductsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StockServiceServer).AddProducts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StockService_AddProducts_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StockServiceServer).AddProducts(ctx, req.(*stockApi.AddProductsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StockService_GetProducts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(stockApi.GetProductsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StockServiceServer).GetProducts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StockService_GetProducts_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StockServiceServer).GetProducts(ctx, req.(*stockApi.GetProductsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StockService_RemoveProduct_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(stockApi.RemoveProductRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StockServiceServer).RemoveProduct(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StockService_RemoveProduct_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StockServiceServer).RemoveProduct(ctx, req.(*stockApi.RemoveProductRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// StockService_ServiceDesc is the grpc.ServiceDesc for StockService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var StockService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "services.StockService",
	HandlerType: (*StockServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddProducts",
			Handler:    _StockService_AddProducts_Handler,
		},
		{
			MethodName: "GetProducts",
			Handler:    _StockService_GetProducts_Handler,
		},
		{
			MethodName: "RemoveProduct",
			Handler:    _StockService_RemoveProduct_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "microservices/api/services/services.proto",
}

const (
	SupplierService_AddSupplier_FullMethodName    = "/services.SupplierService/AddSupplier"
	SupplierService_GetSupplier_FullMethodName    = "/services.SupplierService/GetSupplier"
	SupplierService_RemoveSupplier_FullMethodName = "/services.SupplierService/RemoveSupplier"
	SupplierService_AddProducts_FullMethodName    = "/services.SupplierService/AddProducts"
	SupplierService_RemoveProducts_FullMethodName = "/services.SupplierService/RemoveProducts"
	SupplierService_OrderProduct_FullMethodName   = "/services.SupplierService/OrderProduct"
)

// SupplierServiceClient is the client API for SupplierService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SupplierServiceClient interface {
	AddSupplier(ctx context.Context, in *supplierApi.AddSupplierRequest, opts ...grpc.CallOption) (*supplierApi.AddSupplierReply, error)
	GetSupplier(ctx context.Context, in *supplierApi.GetSupplierRequest, opts ...grpc.CallOption) (*supplierApi.GetSupplierReply, error)
	RemoveSupplier(ctx context.Context, in *supplierApi.RemoveSupplierRequest, opts ...grpc.CallOption) (*supplierApi.RemoveSupplierReply, error)
	AddProducts(ctx context.Context, in *supplierApi.AddProductsRequest, opts ...grpc.CallOption) (*supplierApi.AddProductsReply, error)
	RemoveProducts(ctx context.Context, in *supplierApi.RemoveProductsRequest, opts ...grpc.CallOption) (*supplierApi.RemoveProductsReply, error)
	OrderProduct(ctx context.Context, in *supplierApi.OrderProductRequest, opts ...grpc.CallOption) (*supplierApi.OrderProductReply, error)
}

type supplierServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewSupplierServiceClient(cc grpc.ClientConnInterface) SupplierServiceClient {
	return &supplierServiceClient{cc}
}

func (c *supplierServiceClient) AddSupplier(ctx context.Context, in *supplierApi.AddSupplierRequest, opts ...grpc.CallOption) (*supplierApi.AddSupplierReply, error) {
	out := new(supplierApi.AddSupplierReply)
	err := c.cc.Invoke(ctx, SupplierService_AddSupplier_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *supplierServiceClient) GetSupplier(ctx context.Context, in *supplierApi.GetSupplierRequest, opts ...grpc.CallOption) (*supplierApi.GetSupplierReply, error) {
	out := new(supplierApi.GetSupplierReply)
	err := c.cc.Invoke(ctx, SupplierService_GetSupplier_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *supplierServiceClient) RemoveSupplier(ctx context.Context, in *supplierApi.RemoveSupplierRequest, opts ...grpc.CallOption) (*supplierApi.RemoveSupplierReply, error) {
	out := new(supplierApi.RemoveSupplierReply)
	err := c.cc.Invoke(ctx, SupplierService_RemoveSupplier_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *supplierServiceClient) AddProducts(ctx context.Context, in *supplierApi.AddProductsRequest, opts ...grpc.CallOption) (*supplierApi.AddProductsReply, error) {
	out := new(supplierApi.AddProductsReply)
	err := c.cc.Invoke(ctx, SupplierService_AddProducts_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *supplierServiceClient) RemoveProducts(ctx context.Context, in *supplierApi.RemoveProductsRequest, opts ...grpc.CallOption) (*supplierApi.RemoveProductsReply, error) {
	out := new(supplierApi.RemoveProductsReply)
	err := c.cc.Invoke(ctx, SupplierService_RemoveProducts_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *supplierServiceClient) OrderProduct(ctx context.Context, in *supplierApi.OrderProductRequest, opts ...grpc.CallOption) (*supplierApi.OrderProductReply, error) {
	out := new(supplierApi.OrderProductReply)
	err := c.cc.Invoke(ctx, SupplierService_OrderProduct_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SupplierServiceServer is the server API for SupplierService service.
// All implementations must embed UnimplementedSupplierServiceServer
// for forward compatibility
type SupplierServiceServer interface {
	AddSupplier(context.Context, *supplierApi.AddSupplierRequest) (*supplierApi.AddSupplierReply, error)
	GetSupplier(context.Context, *supplierApi.GetSupplierRequest) (*supplierApi.GetSupplierReply, error)
	RemoveSupplier(context.Context, *supplierApi.RemoveSupplierRequest) (*supplierApi.RemoveSupplierReply, error)
	AddProducts(context.Context, *supplierApi.AddProductsRequest) (*supplierApi.AddProductsReply, error)
	RemoveProducts(context.Context, *supplierApi.RemoveProductsRequest) (*supplierApi.RemoveProductsReply, error)
	OrderProduct(context.Context, *supplierApi.OrderProductRequest) (*supplierApi.OrderProductReply, error)
	mustEmbedUnimplementedSupplierServiceServer()
}

// UnimplementedSupplierServiceServer must be embedded to have forward compatible implementations.
type UnimplementedSupplierServiceServer struct {
}

func (UnimplementedSupplierServiceServer) AddSupplier(context.Context, *supplierApi.AddSupplierRequest) (*supplierApi.AddSupplierReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddSupplier not implemented")
}
func (UnimplementedSupplierServiceServer) GetSupplier(context.Context, *supplierApi.GetSupplierRequest) (*supplierApi.GetSupplierReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSupplier not implemented")
}
func (UnimplementedSupplierServiceServer) RemoveSupplier(context.Context, *supplierApi.RemoveSupplierRequest) (*supplierApi.RemoveSupplierReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveSupplier not implemented")
}
func (UnimplementedSupplierServiceServer) AddProducts(context.Context, *supplierApi.AddProductsRequest) (*supplierApi.AddProductsReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddProducts not implemented")
}
func (UnimplementedSupplierServiceServer) RemoveProducts(context.Context, *supplierApi.RemoveProductsRequest) (*supplierApi.RemoveProductsReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveProducts not implemented")
}
func (UnimplementedSupplierServiceServer) OrderProduct(context.Context, *supplierApi.OrderProductRequest) (*supplierApi.OrderProductReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OrderProduct not implemented")
}
func (UnimplementedSupplierServiceServer) mustEmbedUnimplementedSupplierServiceServer() {}

// UnsafeSupplierServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SupplierServiceServer will
// result in compilation errors.
type UnsafeSupplierServiceServer interface {
	mustEmbedUnimplementedSupplierServiceServer()
}

func RegisterSupplierServiceServer(s grpc.ServiceRegistrar, srv SupplierServiceServer) {
	s.RegisterService(&SupplierService_ServiceDesc, srv)
}

func _SupplierService_AddSupplier_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(supplierApi.AddSupplierRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SupplierServiceServer).AddSupplier(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SupplierService_AddSupplier_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SupplierServiceServer).AddSupplier(ctx, req.(*supplierApi.AddSupplierRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SupplierService_GetSupplier_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(supplierApi.GetSupplierRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SupplierServiceServer).GetSupplier(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SupplierService_GetSupplier_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SupplierServiceServer).GetSupplier(ctx, req.(*supplierApi.GetSupplierRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SupplierService_RemoveSupplier_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(supplierApi.RemoveSupplierRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SupplierServiceServer).RemoveSupplier(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SupplierService_RemoveSupplier_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SupplierServiceServer).RemoveSupplier(ctx, req.(*supplierApi.RemoveSupplierRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SupplierService_AddProducts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(supplierApi.AddProductsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SupplierServiceServer).AddProducts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SupplierService_AddProducts_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SupplierServiceServer).AddProducts(ctx, req.(*supplierApi.AddProductsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SupplierService_RemoveProducts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(supplierApi.RemoveProductsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SupplierServiceServer).RemoveProducts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SupplierService_RemoveProducts_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SupplierServiceServer).RemoveProducts(ctx, req.(*supplierApi.RemoveProductsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SupplierService_OrderProduct_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(supplierApi.OrderProductRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SupplierServiceServer).OrderProduct(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SupplierService_OrderProduct_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SupplierServiceServer).OrderProduct(ctx, req.(*supplierApi.OrderProductRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// SupplierService_ServiceDesc is the grpc.ServiceDesc for SupplierService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var SupplierService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "services.SupplierService",
	HandlerType: (*SupplierServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddSupplier",
			Handler:    _SupplierService_AddSupplier_Handler,
		},
		{
			MethodName: "GetSupplier",
			Handler:    _SupplierService_GetSupplier_Handler,
		},
		{
			MethodName: "RemoveSupplier",
			Handler:    _SupplierService_RemoveSupplier_Handler,
		},
		{
			MethodName: "AddProducts",
			Handler:    _SupplierService_AddProducts_Handler,
		},
		{
			MethodName: "RemoveProducts",
			Handler:    _SupplierService_RemoveProducts_Handler,
		},
		{
			MethodName: "OrderProduct",
			Handler:    _SupplierService_OrderProduct_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "microservices/api/services/services.proto",
}
